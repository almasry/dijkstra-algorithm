package com.algorithmatics.directedgraph.ProblemDomain.Factory;

import com.algorithmatics.directedgraph.Exception.InvalidProblemStatementException;
import com.algorithmatics.directedgraph.ProblemDomain.Entity.Edge;
import com.algorithmatics.directedgraph.ProblemDomain.Respository.CityRepository;
import com.algorithmatics.directedgraph.ProblemDomain.Respository.EdgeRepository;
import com.algorithmatics.directedgraph.ProblemDomain.Entity.City;

import java.util.ArrayList;

public class ProblemElementsFactory {

    private EdgeRepository edgeRepository;
    private CityRepository cityRepository;

    private ArrayList<String> edgeStrings;

    /**
     * @param edgeStrings the string of edges as in: (AB1, AC2, DE3, FD5, .. )
     * @throws InvalidProblemStatementException if it fails to generate problem elements
     */
    public ProblemElementsFactory(ArrayList<String> edgeStrings) throws InvalidProblemStatementException
    {
        this.edgeStrings = edgeStrings;
        this.edgeRepository = new EdgeRepository();
        this.cityRepository = new CityRepository();

        this.generateProblemElements();
    }

    /**
     * @throws InvalidProblemStatementException if it fails to generate problem elements
     */
    private void generateProblemElements() throws InvalidProblemStatementException
    {
        for (String edgeString : this.edgeStrings) {
            ArrayList<City> cities = this.getEdgeCities(edgeString);

            this.createEdges(cities, edgeString);
        }
    }

    /**
     * @param edgeString string that represents the edge
     * @return list of the cities generated from the edge
     */
    private ArrayList<City> getEdgeCities(String edgeString)
    {
        City startCity = new City(Character.toString(edgeString.charAt(0))) ;
        City endCity = new City(Character.toString(edgeString.charAt(1))) ;

        this.cityRepository.addCity(startCity);
        this.cityRepository.addCity(endCity);

        ArrayList<City> cities = new ArrayList<>();

        cities.add(startCity);
        cities.add(endCity);

        return cities;
    }

    /**
     * @param edgeCities array of both the start and end cities of the edge after being processed (extracted)
     * @param edgeString the string that represents the edge
     * @throws InvalidProblemStatementException if it fails to create a valid edge repository
     */
    private void createEdges(ArrayList<City> edgeCities, String edgeString) throws InvalidProblemStatementException
    {
        City startCity = edgeCities.get(0);
        City endCity   = edgeCities.get(1);

        // preparing the edge to be parsed and deleting city names from the edge
        StringBuilder stringBuilder = new StringBuilder(edgeString);
        stringBuilder.delete(0,2);

        // parsing edge length
        int edgeLength = Integer.parseInt(stringBuilder.toString());

        Edge edge = new Edge(startCity, endCity, edgeLength);

        for(Edge e : this.edgeRepository.getAllEdges()) {

            String nameOfStartCity = e.getStart().getCityName();
            String nameOfEndCity   = e.getEnd().getCityName();

            // making sure the edge doesn't start and end at the same city
            if(nameOfStartCity.equals(nameOfEndCity))
            {
                throw new InvalidProblemStatementException(edgeString+ " : edge can't start and end at the same city..");
            }

            // making sure the edge is not registered before (eg:  you can't have AB5 and AB8 at the same problem)
            if(nameOfStartCity.equals(startCity.getCityName()) && nameOfEndCity.equals(endCity.getCityName()))
            {
                throw new InvalidProblemStatementException("Edge "+edgeString+" can't be registered twice !");
            }
        }
        this.edgeRepository.addEdge(edge);
    }

    /**
     * @return retrieves the repository of edges generated by the problem factory
     */
    public EdgeRepository getEdgeRepository() {
        return edgeRepository;
    }

    /**
     * @return retrieves the repository of cities generated by the problem factory
     */
    public CityRepository getCityRepository() {
        return cityRepository;
    }
}
